Smooth Continuous Modulation with MPR121 on Daisy Seed
Reading Continuous Touch Values vs. Binary States
The MPR121 capacitive sensor can provide more than just binary touch on/off signals – it reports a 10-bit filtered reading for each electrode via its registers​
electro-smith.github.io
. This “filtered data” represents the measured capacitance after internal noise filtering, which can be used as a continuous control value instead of a simple boolean. In other words, you can read an analog-like value (0–1023) indicating how strongly or how much of the pad is being touched, rather than a 0/1 state. However, note: the current Daisy Mpr121 driver had a bug where FilteredData() always returned 0 or 1 (essentially mirroring the binary Touched() result)​
forum.electro-smith.com
​
forum.electro-smith.com
. In practice, you should expect a stream of varying values when reading the filtered data (as confirmed by Adafruit’s MPR121 library)​
forum.electro-smith.com
. If you encounter this issue, consider updating libDaisy (if a fix is available) or reading the sensor registers directly (e.g. via ReadRegister16) to get the true 10-bit measurement. Using a known Arduino/Adafruit MPR121 library as reference (even if adapting to Daisy C++) can help ensure you’re grabbing the correct registers for raw data. Also be aware that the MPR121 auto-calibrates its baseline capacitance continuously. By default it adjusts the “baseline” while running, which can cause the raw filtered values to drift back toward zero even during a steady touch​
crimier.github.io
. For more stable continuous readings, you might disable rapid baseline tracking (e.g. via the ECR register’s filtering settings​
crimier.github.io
), so that a sustained touch doesn’t get “calibrated out” immediately. This will make the sensor act more like a fixed baseline touch sensor, at the cost of needing manual recalibration if environment conditions change. Lastly, keep expectations reasonable: The MPR121 was designed for touch detection, not precise pressure sensing. As one Daisy forum expert noted, it doesn’t truly measure “pressure” – you basically get on/off, and while the “raw” value is available, it may not correlate linearly with actual pressure or finger force​
forum.electro-smith.com
. In other words, you can use the filtered value for continuous control, but it will be a rough indicator (based on contact size/proximity) rather than a true pressure sensor reading. Capacitive sensors in general are noisy and require calibration; if true pressure or highly stable analog control is needed, a different sensor might be more appropriate​
instructables.com
. That said, you can leverage the MPR121 readings for expressive control with proper smoothing.
Smoothing and Filtering the Touch Input
Directly mapping the raw touch values to audio parameters will likely cause audible clicking, zipper noise, or distortion. This is because even with the MPR121’s internal filtering, the readings can jitter from sample to sample. Sudden jumps in a control signal (for example, an amplitude or pitch parameter) introduce high-frequency components into the audio path, manifesting as clicks. The solution is to low-pass filter (smooth) the control signal so that it changes more gradually. Here are some strategies for smoothing the MPR121 output:
Exponential Moving Average (One-Pole Filter): This is simple and efficient. Keep a floating-point accumulator for the parameter and on each new sensor reading, blend it by a factor α. For example:
cpp
Copy
uint16_t raw = mpr121.ReadRegister16(0x04 + 2*channel); // low-level read of FILTDATA registers
float val = float(raw) / 1023.0f;    // normalize 10-bit value to 0.0–1.0 range
// One-pole low-pass filter: y[n] = (1 - α)*y[n-1] + α*x[n]
const float α = 0.1f;               // smoothing factor (0 = no change, 1 = no smoothing)
smoothed_val = smoothed_val + α * (val - smoothed_val);
In the above, smoothed_val will respond to changes in val slowly. A smaller α (e.g. 0.05–0.2) means heavier smoothing (more stable, but more lag), whereas α closer to 1.0 tracks the raw value more quickly (less lag, but more potential jitter). You can adjust this factor to taste. This exponential filter is essentially a one-pole IIR low-pass on the control signal.
Moving Average (Finite Impulse Response): Keep a short buffer of the last N readings and average them. For example, sum the last 4 or 8 samples of filteredData for a given pad and divide by N. This will smooth out rapid fluctuations. The larger N is, the smoother (but also more delayed) the response. A moving average is simple but can introduce more lag than an exponential filter for comparable smoothing. It can be useful if you want a fixed small delay but very stable output.
Debounce and Thresholding: If you find the lowest bits of the filtered value are flickering even when not touched, you can apply a noise floor. For instance, ignore values below a certain threshold (treat them as 0), or quantize small changes. The MPR121’s built-in touch detection uses separate touch/release thresholds for hysteresis​
adafruit.github.io
, but for continuous use you might implement your own minor hysteresis to avoid the output floating when near zero. That said, if you use a good smoothing filter, minor fluctuations will be ironed out naturally.
Rate Limiting / Slew Limiting: Ensure that the parameter you’re modulating doesn’t change too fast. This is essentially what the above filters do. You could also explicitly cap the maximum change per audio block or per millisecond. For example, if changing a frequency, you might limit it to X semitones per second max. This approach is more complex and usually unnecessary if a simple filter is in place, but it’s conceptually another layer of protection against abrupt jumps.
DSP best practice: treat the touch sensor like a control-rate signal. Read it at a lower rate (e.g. 100–1000 Hz) and filter it before applying to your audio engine. This way, any residual noise or step will be out of the audible band. The goal is to make parameter transitions smooth over a few milliseconds instead of a single sample instant.
Implementation on Daisy (libDaisy/DaisySP)
On the Daisy Seed, you typically have an audio callback running at 48 kHz (or similar), and a main loop. It’s wise to decouple the sensor reading from the audio callback to avoid blocking the audio thread. MPR121 uses I²C, which is relatively slow. In fact, reading all 12 channels’ filtered data can take on the order of ~6 milliseconds over I²C, whereas reading the binary touch status is <1 ms​
forums.adafruit.com
. You should not perform a 6 ms I²C transaction in a high-priority audio callback that runs every 1–2 ms (for a typical block size), as this would starve the audio processing and cause glitches in output. Instead, consider these approaches:
Poll in main loop: Initialize the MPR121 in your main() and then, in the infinite loop (while audio is running), query the sensor at a fixed interval. For example, read the touch data every 10ms (which is 100 Hz). You can use System::Delay(10) in between reads, or accumulate elapsed time using a timer. Update your smoothed values there. The audio callback can then simply use the latest smoothed value (perhaps stored in a global or static struct) when computing audio. Since the smoothing filter itself adds some latency, polling at 100 Hz is usually sufficient; you could go up to 1 kHz polling if needed, but remember it may tie up the I²C bus a bit.
Use Audio Block Rate for Control: Alternatively, you can set a larger audio block size so that the audio callback is called less frequently (e.g. every 48 samples = 1ms, or every 480 samples = 10ms). Then you could poll the MPR121 once per callback safely. For example, if block size is 48, you might choose to poll every 10th callback to get ~200 Hz updates. This method can work, but be careful to time the I²C reads so they don’t occur too often. A simple counter in the callback can conditionally perform the read and smoothing code every N blocks.
Interrupt-driven (if needed): The MPR121 has an IRQ pin that goes low when a touch state changes. For pure on/off triggers, using that interrupt is great to avoid constant polling. But for continuous values, you likely want regular updates even if the value isn’t crossing a threshold. You could still use the interrupt to trigger a read of the filtered data when something changes significantly. For example, if a touch is detected (IRQ fires), you then start reading the analog value more frequently until release. This can be complex and may not be necessary if a moderate polling rate is fine for your application.
Applying the smoothed value: Once you have a nicely filtered control value (e.g. a float 0.0–1.0 for each pad), you can map it to whatever parameter you want to modulate. Some examples:
Envelope modulation (Gate/Level): Instead of treating the pad as a simple gate (on/off), use the pad’s value to scale the amplitude. For instance, you could feed it as a sustain level in an ADSR, or directly multiply an oscillator’s output by the value (for a simple volume control). If you want the touch to trigger an envelope, you might use the touch onset as a gate trigger, but also modulate the envelope’s overall amplitude or decay with the continuous value. The key is that when the finger is fully on, the envelope goes to full level smoothly, and when the finger is released, you either trigger the release stage or smoothly ramp down the amplitude.
Pitch or Filter modulation: You can map the 0–1 range to a frequency range. For example, add a vibrato or pitch bend: osc.SetFreq(baseFreq + pitchRange * smoothed_val). If the finger is not touching, smoothed_val will be ~0, so freq = baseFreq. A light touch might raise the pitch slightly. Thanks to smoothing, this will sound like a gentle bend rather than a stepped glitch. The same idea applies to filter cutoff, effect mix, etc.
MIDI-like effects (Velocity): If you wanted to mimic “velocity” of a strike, one approach is to measure how quickly the value rises when a touch occurs. For example, you detect a touch event (using the binary status or a threshold on the analog value) and then look at the first few readings of the filtered value – a faster increase could be interpreted as a higher velocity. This is an advanced technique and may be limited by the sensor’s responsiveness. Remember MPR121 wasn’t really made for true velocity sensing, but you can get creative. In many cases, simply using the continuous value as an aftertouch (pressure-like) control is easier and still musically useful.
Below is a pseudo-code example combining these ideas in a Daisy context:
cpp
Copy
#include "daisy_seed.h"
#include "daisysp.h"
#include "dev/mpr121.h"
using namespace daisy;
using namespace daisysp;

DaisySeed hw;
Mpr121I2C mpr121;
float touchVal[12] = {0};      // smoothed values for each pad (0.0–1.0)
const float alpha = 0.1f;      // smoothing factor

void AudioCallback(AudioHandle::InputBuffer in, AudioHandle::OutputBuffer out, size_t size) {
    // Use the smoothed touchVal[] in audio processing
    float mod = touchVal[0];  // e.g., use pad0 to modulate something
    for (size_t i = 0; i < size; i++) {
        float sample = osc.Process();
        // Apply volume modulation by pad0:
        out[0][i] = sample * mod;
        out[1][i] = sample * mod;
    }
}

int main(void) {
    hw.Configure();
    hw.Init();
    // Init MPR121 (assumes default I2C1 pins and address 0x5A)
    Mpr121I2C::Config mprConfig;
    mprConfig.transport_config.periph = I2CHandle::Config::Peripheral::I2C_1;
    mprConfig.transport_config.speed  = I2CHandle::Config::Speed::I2C_400KHZ;
    mpr121.Init(mprConfig);
    mpr121.SetThresholds(12, 6);  // set touch/release thresholds if needed
    
    osc.Init(hw.AudioSampleRate());
    osc.SetWaveform(Oscillator::WAVE_SIN);
    osc.SetFreq(440);
    osc.SetAmp(0.5);
    hw.StartAudio(AudioCallback);

    uint32_t lastPoll = hw.System.GetNow();  // current time in ms
    while(1) {
        // Poll every 5 ms (200 Hz) for new sensor data
        if(hw.System.GetNow() - lastPoll >= 5) {
            lastPoll = hw.System.GetNow();
            // Read filtered values for each channel
            for(int ch = 0; ch < 12; ++ch) {
                uint16_t raw = mpr121.FilteredData(ch);
                float norm = float(raw) / 1023.0f;
                // Exponential smoothing
                touchVal[ch] += alpha * (norm - touchVal[ch]);
            }
        }
        // ... other non-audio tasks ...
    }
}
In this example, the audio callback runs continuously and uses the global touchVal (which is being updated in the main loop). We poll the MPR121 every 5 milliseconds to update touchVal[ch] with a smoothed reading. Pad 0’s value is then used to modulate the oscillator’s amplitude in real-time. Because of the smoothing, the amplitude changes will be gentle, avoiding clicks. Important: if using this approach, the touchVal array should ideally be updated in a thread-safe way since it’s shared between the ISR (audio callback) and main loop. On a microcontroller, if the update is a single float assignment, it’s usually fine, but for absolute safety you might disable interrupts for a microsecond during the copy or use a mutex (if an RTOS is running). In practice for simple cases, it’s rarely an issue.